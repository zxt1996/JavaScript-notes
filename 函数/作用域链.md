# 作用域链
- 变量对象(Variable object，VO)
- 函数上下文中，变量对象被表示为活动对象AO
## 函数创建
- [[Scope]]  
  
函数中存在的一个内部属性[[Scope]](我们不能使用，供js引擎使用)，函数被创建时，这个内部属性就会包含函数被创建的作用域中对象的集合，这个集合呈链式链接，被称为函数的**作用域链**，作用域上的每一个对象被称为可变对象(Variable Object),每一个可变对象都以键值对形式存在。   

**函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中**
```
function foo(){
    function bar(){
        ...
    }
}
```
函数创建时，各自的[[scope]]为
```
foo.[[scope]] = [
    globalContext.VO
];

bar.[[scope]]=[
    fooContext.AO,
    globalContext.VO
];
```

## 函数激活
当函数激活时，进入函数上下文，创建VO/AO后，就会将活动对象添加到作用链的前端。  
这时候执行上下文的作用域链，命名为Scope  
```
Scope = [AO].concat([[Scope]])
```

## 通过构造函数创建的函数的[[scope]]
```
var x = 10;
 
function foo() {
 
  var y = 20;
 
  function barFD() { // 函数声明
    alert(x);
    alert(y);
  }
 
  var barFE = function () { // 函数表达式
    alert(x);
    alert(y);
  };
 
  var barFn = Function('alert(x); alert(y);');
 
  barFD(); // 10, 20
  barFE(); // 10, 20
  barFn(); // 10, "y" is not defined
 
}
 
foo();
```
**通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。**  
考虑到这一点，如通过这种函数创建除全局之外的最上层的上下文闭包是不可能的。