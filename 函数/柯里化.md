# 柯里化
柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。  
1. 第一版

```
//第一版

var curry = function(fn){
    var args = [].slice.call(arguments,1);
    return function(){
        var newArgs = args.concat([].slice.call(arguments));
        return fn.apply(this,newArgs);
    };
};
```
**[].slice.call(arguments)能将具有length属性的对象转成数组**  
[].slice.call(arguments,1)是为了排除我们传入的函数   
使用 
```
function add(a, b) {
    return a + b;
}

var addCurry = curry(add, 1, 2);
addCurry() // 3
//或者
var addCurry = curry(add, 1);
addCurry(2) // 3
//或者
var addCurry = curry(add);
addCurry(1, 2) // 3
``` 

2. 第二版  
   sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(...)(...) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。
```
//第二版
function sub_curry(fn){
    var args = [].slice.call(arguments,1);
    return function(){
        return fn.apply(this,args.concat([].slice.call(arguments)));
    };
}

function curry(fn,length){
    length = length || fn.length;

    var slice = Array.prototype.slice;

    return function(){
        if(arguments.length < length){
            var combined = [fn].concat(slice.call(arguments));
            return curry(sub_curry.apply(this,combined),length-arguments.length);
        }else{
            return fn.apply(this,arguments);
        }
    };
}
```
Function.length指明函数的形参个数。
```
var fn = curry(function(a, b, c) {
    return [a, b, c];
});

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```

3. 易理解版

```
function curry(fn,currArgs){
    return function(){
        let args = [].slice.call(arguments);

        //用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数

        //首次调用时，若未提供最后一个参数currArgs,则不用进行args的拼接
        if(currArgs !== undefined){
            args = args.concat(currArgs);
        }

        //递归调用
        if(args.length < fn.length){
            return curry(fn,args);
        }

        //递归出口
        return fn.apply(null,args);
    }
}
```
判断 args 的个数，是否与 fn (也就是 sum )的参数个数相等，相等了就可以把参数都传给 fn，进行输出；否则，继续递归调用，直到两者相等。
```
function sum(a, b, c) {
    console.log(a + b + c);
}

const fn = curry(sum);

fn(1, 2, 3); // 6
fn(1, 2)(3); // 6
fn(1)(2, 3); // 6
fn(1)(2)(3); // 6
```