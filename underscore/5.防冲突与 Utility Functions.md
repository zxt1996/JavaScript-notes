# 防冲突与 Utility Functions
## 防冲突
underscore 使用 _ 作为函数的挂载对象，如果页面中已经存在了 _ 对象，underscore 就会覆盖该对象

```
var _ = {value: 1 }

// 引入 underscore 后
console.log(_.value); // undefined
```
所以 underscore 提供了 noConflict 功能，可以放弃 underscore 的控制变量 _，返回 underscore 对象的引用。

```
var _ = {value: 1 }

// 引入 underscore 后

// 放弃 "_"，使用 "$"
var $ = _.noConflict();

console.log(_.value); // 1

// 使用 underscore 的方法
$.each([1, 2, 3], alert);
```
在 underscore 执行的时候，会储存之前的 _ 对象，然后当执行 noConflict 函数的时候，再将之前储存的 _ 对象赋给全局对象，最后返回 underscore 对象。这样，我们就可以利用返回的 underscore 对象使用 underscore 提供的各种方法。

```
//保存对_的指向
var previousUnderscore = root._;

// var underscore = _.noConflict();
// underscore.each(..);
_.noConflict = function(){
    //重新指向_
  root._ = previousUnderscore;
  //this指向的是_.noConflict中的_,即返回自身
  return this;
};
```